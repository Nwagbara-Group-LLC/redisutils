name: Redis Utils CI/CD

on:
  push:
    branches: [ main, develop, 'release/**' ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod

env:
  REGISTRY: tradingplatformacr.azurecr.io
  IMAGE_NAME: redis-utils
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  test:
    name: Test Redis Utils
    runs-on: ubuntu-latest
    strategy:
      matrix:
        rust: [stable, beta]
        redis: [6, 7]
    
    services:
      redis:
        image: redis:${{ matrix.redis }}-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@master
      with:
        toolchain: ${{ matrix.rust }}
        components: rustfmt, clippy
        
    - name: Cache Rust dependencies
      uses: Swatinem/rust-cache@v2
      with:
        prefix-key: "v1-rust"
        shared-key: "redis-utils"
        
    - name: Check formatting
      run: cargo fmt -- --check
      
    - name: Run Clippy
      run: cargo clippy --all-targets -- -D warnings
      
    - name: Build project
      run: cargo build --verbose
      
    - name: Run unit tests
      run: cargo test --verbose
      env:
        RUST_LOG: debug
        REDIS_URL: redis://localhost:6379
        
    - name: Run integration tests
      run: cargo test --test '*' --verbose
      env:
        REDIS_URL: redis://localhost:6379
        
    - name: Test Redis connection pool
      run: |
        cargo test redis_pool_tests --verbose
      env:
        REDIS_URL: redis://localhost:6379
        
    - name: Test Redis clustering support
      run: |
        # Start Redis cluster nodes for testing
        docker run -d --name redis-cluster-test \
          -p 7000-7005:7000-7005 \
          grokzen/redis-cluster:latest
        sleep 10
        
        # Run cluster tests
        cargo test cluster_tests --verbose || true
        
        # Cleanup
        docker stop redis-cluster-test
        docker rm redis-cluster-test
        
    - name: Generate test coverage
      if: matrix.rust == 'stable' && matrix.redis == '7'
      run: |
        cargo install cargo-tarpaulin
        cargo tarpaulin --verbose --all-features --workspace --timeout 120 --out xml
        
    - name: Upload coverage to Codecov
      if: matrix.rust == 'stable' && matrix.redis == '7'
      uses: codecov/codecov-action@v3
      with:
        file: ./cobertura.xml
        flags: unittests
        name: redis-utils-coverage

  security:
    name: Security Audit
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable
      
    - name: Cache Rust dependencies  
      uses: Swatinem/rust-cache@v2
      
    - name: Run security audit
      run: |
        cargo install cargo-audit
        cargo audit
        
    - name: Run vulnerability scan
      run: |
        cargo install cargo-deny
        cargo deny check

  publish-crate:
    name: Publish to Crates.io
    runs-on: ubuntu-latest
    needs: [test, security]
    if: github.ref == 'refs/heads/main' && contains(github.event.head_commit.message, '[publish]')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable
      
    - name: Cache Rust dependencies
      uses: Swatinem/rust-cache@v2
      
    - name: Check if version is already published
      run: |
        CRATE_VERSION=$(grep '^version = ' Cargo.toml | head -1 | sed 's/version = "\(.*\)"/\1/')
        echo "Current version: $CRATE_VERSION"
        
        if cargo search redis-utils --limit 1 | grep -q "redis-utils = \"$CRATE_VERSION\""; then
          echo "Version $CRATE_VERSION already published"
          exit 1
        fi
        
    - name: Publish to crates.io
      run: cargo publish --token ${{ secrets.CRATES_IO_TOKEN }}

  build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: [test, security]
    if: github.event_name != 'pull_request'
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.REGISTRY }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          RUST_VERSION=1.75
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
          VCS_REF=${{ github.sha }}

  deploy-dev:
    name: Deploy Utilities to Development
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/develop' || github.event.inputs.environment == 'dev'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS_DEV }}
        
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
        
    - name: Get AKS credentials
      run: |
        az aks get-credentials --resource-group ${{ secrets.AZURE_RG_DEV }} --name ${{ secrets.AKS_CLUSTER_DEV }}
        
    - name: Deploy Redis utilities
      run: |
        kubectl create configmap redis-utils-config \
          --from-file=config/ \
          --namespace trading-platform-dev \
          --dry-run=client -o yaml | \
        kubectl apply -f -
        
        # Deploy as a library - create init container for other services
        kubectl patch deployment data-engine-dev \
          --patch '{"spec":{"template":{"spec":{"initContainers":[{"name":"redis-utils","image":"'${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}'","command":["cp","-r","/usr/local/lib/redis-utils","/shared"],"volumeMounts":[{"name":"shared-libs","mountPath":"/shared"}]}],"volumes":[{"name":"shared-libs","emptyDir":{}}],"containers":[{"name":"data-engine","volumeMounts":[{"name":"shared-libs","mountPath":"/usr/local/lib/shared"}]}]}}}}' \
          --namespace trading-platform-dev

  deploy-staging:
    name: Deploy Utilities to Staging
    runs-on: ubuntu-latest
    needs: [build, deploy-dev]
    if: startsWith(github.ref, 'refs/heads/release/') || github.event.inputs.environment == 'staging'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS_STAGING }}
        
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
        
    - name: Get AKS credentials
      run: |
        az aks get-credentials --resource-group ${{ secrets.AZURE_RG_STAGING }} --name ${{ secrets.AKS_CLUSTER_STAGING }}
        
    - name: Deploy Redis utilities
      run: |
        kubectl create configmap redis-utils-config \
          --from-file=config/ \
          --namespace trading-platform-staging \
          --dry-run=client -o yaml | \
        kubectl apply -f -
        
        # Update all services to use the new utilities version
        for service in data-engine message-broker-engine signal-engine; do
          kubectl patch deployment ${service}-staging \
            --patch '{"spec":{"template":{"spec":{"initContainers":[{"name":"redis-utils","image":"'${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}'","command":["cp","-r","/usr/local/lib/redis-utils","/shared"],"volumeMounts":[{"name":"shared-libs","mountPath":"/shared"}]}],"volumes":[{"name":"shared-libs","emptyDir":{}}],"containers":[{"name":"'${service}'","volumeMounts":[{"name":"shared-libs","mountPath":"/usr/local/lib/shared"}]}]}}}}' \
            --namespace trading-platform-staging || echo "Service $service not found, skipping..."
        done

  deploy-prod:
    name: Deploy Utilities to Production
    runs-on: ubuntu-latest
    needs: [build, deploy-staging]
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'prod'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS_PROD }}
        
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
        
    - name: Get AKS credentials
      run: |
        az aks get-credentials --resource-group ${{ secrets.AZURE_RG_PROD }} --name ${{ secrets.AKS_CLUSTER_PROD }}
        
    - name: Deploy Redis utilities with rolling update
      run: |
        kubectl create configmap redis-utils-config \
          --from-file=config/ \
          --namespace trading-platform \
          --dry-run=client -o yaml | \
        kubectl apply -f -
        
        # Perform rolling update of all services
        for service in data-engine message-broker-engine signal-engine; do
          echo "Updating $service with new Redis utilities..."
          kubectl patch deployment $service \
            --patch '{"spec":{"template":{"spec":{"initContainers":[{"name":"redis-utils","image":"'${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}'","command":["cp","-r","/usr/local/lib/redis-utils","/shared"],"volumeMounts":[{"name":"shared-libs","mountPath":"/shared"}]}],"volumes":[{"name":"shared-libs","emptyDir":{}}],"containers":[{"name":"'${service}'","volumeMounts":[{"name":"shared-libs","mountPath":"/usr/local/lib/shared"}]}]}}}}' \
            --namespace trading-platform || echo "Service $service not found, skipping..."
            
          # Wait for rollout to complete
          kubectl rollout status deployment/$service --timeout=300s --namespace trading-platform || echo "Service $service rollout timeout"
        done

  integration-test:
    name: Integration Test
    runs-on: ubuntu-latest
    needs: [deploy-dev]
    if: github.ref == 'refs/heads/develop'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS_DEV }}
        
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
        
    - name: Get AKS credentials
      run: |
        az aks get-credentials --resource-group ${{ secrets.AZURE_RG_DEV }} --name ${{ secrets.AKS_CLUSTER_DEV }}
        
    - name: Test Redis utilities integration
      run: |
        kubectl run redis-utils-test --rm -i --restart=Never \
          --image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
          --namespace=trading-platform-dev \
          -- /usr/local/bin/test-redis-integration

  notification:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: [deploy-dev, deploy-staging, deploy-prod, integration-test]
    if: always()
    
    steps:
    - name: Notify Slack
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#infrastructure'
        text: |
          RedisUtils deployment completed
          Environment: ${{ github.event.inputs.environment || 'auto' }}
          Status: ${{ job.status }}
          Commit: ${{ github.sha }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
